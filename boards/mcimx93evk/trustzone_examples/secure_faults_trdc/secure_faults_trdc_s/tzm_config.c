/*
 * Copyright 2022 NXP
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */
/***********************************************************************************************************************
 * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
 * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
 **********************************************************************************************************************/

/* clang-format off */
/* TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
!!GlobalInfo
product: TEE v4.0
processor: MIMX9352xxxxM
package_id: MIMX9352DVVXM
mcu_data: ksdk2_0
processor_version: 0.12.3
toolOptions:
  _legacy_source_names_: 'no'
 * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS **********/
/* clang-format on */

/***********************************************************************************************************************
 * Included files
 **********************************************************************************************************************/
#include "fsl_common.h"
#include "tzm_config.h"
#include "fsl_trdc.h"
#include "fsl_sentinel.h"
#include "fsl_debug_console.h"

/***********************************************************************************************************************
 * Definitions
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * BOARD_InitTrustZone function
 **********************************************************************************************************************/

void BOARD_ReleaseTRDC(void)
{
    /* Release TRDC(transfer owner of TRDC from s400 to m33) */
    SENTINEL_ReleaseRDC(TRDC_TYPE);
}

void App_SetTrdcMBCNSE(uint8_t mbcIdx, uint8_t slvIdx, uint8_t mbIdx, uint32_t nse)
{
    /* Set the MBC slave memory block configuration and select the memory access control of no access for this memory
     * block */
    trdc_mbc_memory_block_config_t mbcBlockConfig;
    (void)memset(&mbcBlockConfig, 0, sizeof(mbcBlockConfig));
    mbcBlockConfig.memoryAccessControlSelect = EXAMPLE_TRDC_MBC_ACCESS_CONTROL_POLICY_ALL_INDEX;
    /* CPU is secure mode by default, enable NSE bit to disable secure access. */
    mbcBlockConfig.nseEnable      = nse;
    mbcBlockConfig.mbcIdx         = mbcIdx;
    mbcBlockConfig.domainIdx      = TRDC_GetCurrentMasterDomainId(TRDC1);
    mbcBlockConfig.slaveMemoryIdx = slvIdx;
    mbcBlockConfig.memoryBlockIdx = mbIdx;

    TRDC_MbcSetMemoryBlockConfig(TRDC1, &mbcBlockConfig);
}

void APP_PrintTrdcErr(void)
{
    trdc_domain_error_t error;

    if (kStatus_Success == TRDC_GetAndClearFirstDomainError(TRDC1, &error))
    {
        if (error.controller == kTRDC_MemRegionChecker0)
        {
            PRINTF("TRDC MRC Violent access \r\n");
        }
        if (error.controller == kTRDC_MemBlockController0)
        {
            PRINTF("TRDC MBC slavemem:%d Violent access \r\n", error.slaveMemoryIdx);
        }
        PRINTF("    domainId        : %d\r\n", error.domainId);
        PRINTF("    Address         : 0x%08X\r\n", error.address);
        PRINTF("    Error state     : %d\r\n", error.errorState);
        PRINTF("    Error attribute : %d\r\n", error.errorAttr);
        PRINTF("    Error type      : %d\r\n", error.errorType);
        PRINTF("    Error port      : %d\r\n", error.errorPort);
    }
}
void APP_SetTrdcGlobalConfig(void)
{
    uint32_t i;
    BOARD_ReleaseTRDC();
    for (i = 16; i < 32; i++)
    {
        App_SetTrdcMBCNSE(1, 0, i, 1);
    }

    for (i = 19; i < 30; i++)
    {
        App_SetTrdcMBCNSE(1, 1, i, 1);
    }
}
void BOARD_InitTrustZone()
{
    /* SAU configuration */

    /* Set SAU Control register: Disable SAU and All Secure */
    SAU->CTRL = 0;

    /* Set SAU region number */
    SAU->RNR = 0;
    /* Region base address */
    SAU->RBAR = SAU_REGION_0_BASE & SAU_RBAR_BADDR_Msk;
    /* Region end address */
    SAU->RLAR = (SAU_REGION_0_END & SAU_RLAR_LADDR_Msk) | ((0U << SAU_RLAR_NSC_Pos) & SAU_RLAR_NSC_Msk) |
                ((1U << SAU_RLAR_ENABLE_Pos) & SAU_RLAR_ENABLE_Msk);

    /* Set SAU region number */
    SAU->RNR = 1;
    /* Region base address */
    SAU->RBAR = SAU_REGION_1_BASE & SAU_RBAR_BADDR_Msk;
    /* Region end address */
    SAU->RLAR = (SAU_REGION_1_END & SAU_RLAR_LADDR_Msk) | ((0U << SAU_RLAR_NSC_Pos) & SAU_RLAR_NSC_Msk) |
                ((1U << SAU_RLAR_ENABLE_Pos) & SAU_RLAR_ENABLE_Msk);

    /* Set SAU region number */
    SAU->RNR = 2;
    /* Region base address */
    SAU->RBAR = SAU_REGION_2_BASE & SAU_RBAR_BADDR_Msk;
    /* Region end address */
    SAU->RLAR = (SAU_REGION_2_END & SAU_RLAR_LADDR_Msk) | ((1U << SAU_RLAR_NSC_Pos) & SAU_RLAR_NSC_Msk) |
                ((1U << SAU_RLAR_ENABLE_Pos) & SAU_RLAR_ENABLE_Msk);

    /* Set SAU region number */
    SAU->RNR = 3;
    /* Region base address */
    SAU->RBAR = SAU_REGION_3_BASE & SAU_RBAR_BADDR_Msk;
    /* Region end address */
    SAU->RLAR = (SAU_REGION_3_END & SAU_RLAR_LADDR_Msk) | ((0U << SAU_RLAR_NSC_Pos) & SAU_RLAR_NSC_Msk) |
                ((1U << SAU_RLAR_ENABLE_Pos) & SAU_RLAR_ENABLE_Msk);

    /* Force memory writes before continuing */
    __DSB();
    /* Flush and refill pipeline with updated permissions */
    __ISB();

    /* Set SAU Control register: Enable SAU and All Secure (applied only if disabled) */
    SAU->CTRL = ((0U << SAU_CTRL_ALLNS_Pos) & SAU_CTRL_ALLNS_Msk) | ((1U << SAU_CTRL_ENABLE_Pos) & SAU_CTRL_ENABLE_Msk);

    APP_SetTrdcGlobalConfig();

    /*--------------------------------------------------------------------
     - Interrupts: Interrupt security configuration
     -------------------------------------------------------------------*/
    /* Possible values for every interrupt:
     *  0b0    Secure
     *  0b1    Non-secure */
    NVIC->ITNS[0] = 0;
    NVIC->ITNS[1] = 0;

    /* Global Options */
    SCB->AIRCR = (SCB->AIRCR & 0x000009FF7U) | 0x005FA0000U;
    SCB->SCR &= 0x0FFFFFFF7U;
    SCB->SHCSR &= 0x0FFF7FFFFU;
    SCB->NSACR    = 0x00000C03U;
    SCnSCB->CPPWR = 0;
}
